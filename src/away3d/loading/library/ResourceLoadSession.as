package away3d.loading.library{	import away3d.arcane;	import away3d.events.LoaderEvent;	import away3d.events.ResourceEvent;	import away3d.loading.AssetLoader;	import away3d.loading.library.ResourceDependency;	import away3d.loading.parsers.ParserBase;		import flash.events.EventDispatcher;	import flash.net.URLRequest;
		use namespace arcane;
		/**	 * ResourceLoadSession handles loading and parsing of a file and (optionally) all of its dependencies.	 */	internal class ResourceLoadSession extends EventDispatcher	{		private var _dependencyStack : Vector.<Vector.<ResourceDependency>>;		private var _dependencyIndexStack : Vector.<uint>;		private var _currentDependencyIndex : uint;		private var _currentDependencies : Vector.<ResourceDependency>;		private var _uri : String;		private var _ignoreDependencies : Boolean;		private var _loadingDependency : ResourceDependency;		private var _namespace : String;				/**		 * Create a new ResourceLoadSession object.		 */		public function ResourceLoadSession()		{			_dependencyStack = new Vector.<Vector.<ResourceDependency>>();			_dependencyIndexStack = new Vector.<uint>();		}				/**		 * Loads a file and (optionally) all of its dependencies.		 * @param url The url of the main file to be loaded.		 * @param ignoreDependencies Indicates whether or not dependencies should be ignored or loaded.		 * @param parser An optional parser object that will translate the loaded data into a usable resource.		 */		public function load(req : URLRequest, ignoreDependencies : Boolean, parser : ParserBase, namespace : String) : void		{			_namespace = namespace;			_uri = req.url = req.url.replace(/\\/g, "/");			_ignoreDependencies = ignoreDependencies;			_currentDependencies = new Vector.<ResourceDependency>();			_currentDependencies.push(new ResourceDependency('', req, null, null));			retrieveNext(parser);		}				/**		 * Loads a resource from already loaded data.		 * @param data The data to be parsed. Depending on the parser type, this can be a ByteArray, String or XML.		 * @param id The id of the object to be loaded, used for resource management.		 * @param ignoreDependencies Indicates whether or not dependencies should be ignored or loaded.		 * @param parser An optional parser object that will translate the data into a usable resource.		 */		public function parse(data : *, id : String, ignoreDependencies : Boolean, parser : ParserBase, namespace : String) : void		{			_namespace = namespace;			_uri = id;			_ignoreDependencies = ignoreDependencies;			_currentDependencies = new Vector.<ResourceDependency>();			_currentDependencies.push(new ResourceDependency(id, null, data, null));			retrieveNext(parser);		}						/**		 * Recursively retrieves the next to-be-loaded and parsed dependency on the stack, or pops the list off the		 * stack when complete and continues on the top set.		 * @param parser The parser that will translate the data into a usable resource.		 */		private function retrieveNext(parser : ParserBase = null) : void		{			// move back up the stack while we're at the end			while (_currentDependencies && _currentDependencyIndex == _currentDependencies.length) {				if (_dependencyStack.length > 0) {					_currentDependencies = _dependencyStack.pop();					_currentDependencyIndex = _dependencyIndexStack.pop();				}				else _currentDependencies = null;			}						if (_currentDependencies && _currentDependencyIndex<_currentDependencies.length) {				retrieveDependency(_currentDependencies[_currentDependencyIndex], parser);				_currentDependencyIndex++;			} else {				dispatchEvent(new ResourceEvent(ResourceEvent.RESOURCE_RETRIEVED, null, _uri));			}		}				/**		 * Retrieves a single dependency.		 * @param parser The parser that will translate the data into a usable resource.		 */		private function retrieveDependency(dependency : ResourceDependency, parser : ParserBase = null) : void		{			var loader : AssetLoader = new AssetLoader();			loader.addEventListener(LoaderEvent.LOAD_COMPLETE, onRetrievalComplete);			loader.addEventListener(LoaderEvent.LOAD_ERROR, onRetrievalFailed);			loader.addEventListener(ResourceEvent.ASSET_RETRIEVED, onAssetRetrieved);			_loadingDependency = dependency;			if (_loadingDependency.data) {				loader.parseData(_loadingDependency.data, parser);			}			else {				// Resolve URL and start loading				dependency.request.url = resolveDependencyUrl(dependency);				loader.load(dependency.request, parser);			}		}						private function resolveDependencyUrl(dependency : ResourceDependency) : String		{			var abs_re : RegExp;			var base : String;			var url : String = dependency.request.url;						// This is the "base" dependency, i.e. the actual requested asset.			// We will not try to resolve this since the user can probably be 			// thrusted to know this URL better than our automatic resolver. :)			if (url == _uri)				return url;						// Absolute URL? Check if starts with slash or a URL			// scheme definition (e.g. ftp://, http://, file://)			abs_re = new RegExp(/^[a-zA-Z]{3,4}:\/\//);			if (url.charAt(0)=='/' || abs_re.test(url))				return url;						// Since not absolute, just get rid of base file name to find it's			// folder and then concatenate dynamic URL			base = _uri.substring(0, _uri.lastIndexOf('/')+1);			return base.concat(url);		}				/**		 * Called when a single dependency loading failed, and pushes further dependencies onto the stack.		 * @param event		 */		private function onRetrievalFailed(event : LoaderEvent) : void		{			var loader : AssetLoader = AssetLoader(event.target);			loader.removeEventListener(LoaderEvent.PARSE_COMPLETE, onRetrievalComplete);			loader.removeEventListener(LoaderEvent.LOAD_ERROR, onRetrievalFailed);			loader.removeEventListener(ResourceEvent.ASSET_RETRIEVED, onAssetRetrieved);						if(hasEventListener(LoaderEvent.LOAD_ERROR)){				dispatchEvent(new LoaderEvent(LoaderEvent.LOAD_ERROR, loader.url, event.message));			} else{				trace("Unable to load "+loader.url);			}						// TODO: Investigate this. Why is this done?			var ext:String = loader.url.substring(loader.url.length-4, loader.url.length).toLowerCase();			if(ext == ".mtl" || ext ==".jpg" || ext ==".png"){				_loadingDependency.resolveFailure();				prepareNextRetrieve(loader, event, false);			}		}						private function onAssetRetrieved(event : ResourceEvent) : void		{			// Add loaded asset to list of assets retrieved as part			// of the current dependency. This list will be inspected			// by the parent parser when dependency is resolved			if (_loadingDependency)				_loadingDependency.assets.push(event.asset);						event.asset.resetAssetPath(event.asset.name, _namespace);			dispatchEvent(event.clone());		}				/**		 * Called when a single dependency was parsed, and pushes further dependencies onto the stack.		 * @param event		 */		private function onRetrievalComplete(event : LoaderEvent) : void		{			var loader : AssetLoader = AssetLoader(event.target);			loader.removeEventListener(LoaderEvent.PARSE_COMPLETE, onRetrievalComplete);			loader.removeEventListener(LoaderEvent.LOAD_ERROR, onRetrievalFailed);			loader.removeEventListener(ResourceEvent.ASSET_RETRIEVED, onAssetRetrieved);			prepareNextRetrieve(loader, event);		}				/**		 * Pushes further dependencies onto the stack.		 * @param event		 */		private function prepareNextRetrieve(loader:AssetLoader, event : LoaderEvent, resolve:Boolean = true) : void		{			dispatchEvent(new ResourceEvent(ResourceEvent.DEPENDENCY_RETRIEVED, null, event.url));						if(resolve) _loadingDependency.resolve();						if (_ignoreDependencies){				dispatchEvent(new ResourceEvent(ResourceEvent.RESOURCE_RETRIEVED, null, _uri));			} else{				_dependencyStack.push(_currentDependencies);				_dependencyIndexStack.push(_currentDependencyIndex);				_currentDependencyIndex = 0;				_currentDependencies = loader.dependencies;				retrieveNext();			}					}	}}